# Reclaim Protocol Signature Analysis

## Overview

This document analyzes how Reclaim Protocol signatures work and their relationship to claimed data, specifically focusing on the `responseMatches` patterns used for selective disclosure.

## Signature Message Construction

The message that gets signed by witnesses follows this format:

```
identifier\nowner\ntimestamp\nepoch
```

Where:
- `identifier`: Cryptographic hash representing the claim
- `owner`: Application address that requested the proof
- `timestamp`: Unix timestamp when the claim was made
- `epoch`: Witness epoch number

## Example from Proof Analysis

```javascript
const message =
    proof.claimData.identifier.toLowerCase() + '\n' +
    proof.claimData.owner.toLowerCase() + '\n' +
    proof.claimData.timestampS + '\n' +
    proof.claimData.epoch;
```

**Sample values:**
- Identifier: `0xd98d4800e8163a653f26b9f4e7f6a4d14dcacb0fb938371ad3b6d3792b8d1a72`
- Owner: `0x6202d6e4b1c98f4e7e22d7b969dec142aa282ec6`
- Timestamp: `1766587608` (2025-12-24T14:46:48.000Z)
- Epoch: `1`

## Relationship to Claim Data

The signature **does NOT directly sign** the `responseMatches` regex patterns, but instead signs an **identifier** that represents the entire claim.

### Claim Data Structure

```json
{
  "provider": "http",
  "parameters": {
    "method": "GET",
    "url": "https://httpbin.org/get",
    "responseMatches": [
      {
        "type": "regex",
        "value": "\"origin\":\\s*\"(?<origin>[^\"]+)\""
      }
    ],
    "responseRedactions": []
  },
  "context": {
    "extractedParameters": {
      "origin": "13.233.193.107"
    },
    "providerHash": "0x245a11f715ca085fabe2986526a51e43f286650f992dde2d036daf2f16fc1370"
  },
  "identifier": "0xd98d4800e8163a653f26b9f4e7f6a4d14dcacb0fb938371ad3b6d3792b8d1a72"
}
```

### How It Works

1. **Claim Definition**: `responseMatches` defines what data to extract from HTTP responses
2. **Claim Assembly**: This gets embedded in the `parameters` field
3. **Identifier Generation**: The `identifier` is a hash of the claim data (provider + parameters + context)
4. **Signature Creation**: Witness signs the identifier + metadata

## Signature Verification Process

### 1. Message Reconstruction
```javascript
const message = `${identifier}\n${owner}\n${timestamp}\n${epoch}`;
```

### 2. Ethereum Signed Message
The SDK uses `ethers.verifyMessage()` which:
- Converts message to bytes
- Adds Ethereum prefix: `"\x19Ethereum Signed Message:\n" + length`
- Hashes with keccak256
- Recovers signer address from signature

### 3. Witness Validation
- Recovered signer: `0x244897572368eadf65bfbc5aec98d8e5443a9072`
- Expected witness: `0x244897572368eadf65bfbc5aec98d8e5443a9072`
- Match: âœ… YES

## SDK Verification Flow

The `verifyProof()` function:

1. **Witness Retrieval**: Calls `getWitnessesForClaim(epoch, identifier, timestamp)`
2. **Contract Query**: Queries Reclaim contract on Optimism Sepolia
3. **Deterministic Selection**: Contract runs `fetchWitnessesForClaim()`
4. **Signature Verification**: Compares recovered signers with expected witnesses

## Key Insights

### Why This Design?

- **Efficiency**: Sign hash instead of large claim data
- **Binding**: Cryptographically binds witness to specific claim
- **Verification**: Enables checking that witness attested to expected `responseMatches`

### Selective Disclosure

The `responseMatches` pattern:
```regex
"origin":\s*"(?<origin>[^"]+)"
```

- **Extracts**: Origin IP address from HTTP response
- **Proves**: The witness verified a claim that includes this extraction rule
- **Privacy**: Only extracted values are revealed, not the full response

### Identifier Computation

The identifier appears to be computed server-side during proof generation. Attempts to locally compute it from claim data (even with canonicalization) don't match the actual identifier, suggesting it's generated by the Reclaim attestor infrastructure.

## Security Implications

1. **Claim Integrity**: Signature ensures the witness attested to the exact claim
2. **Replay Protection**: Timestamp prevents replay attacks
3. **Witness Accountability**: Epoch ensures witnesses are from the correct set
4. **Application Binding**: Owner field ties proof to requesting application

## Questions for Further Investigation

1. **Identifier Computation**: How exactly is the identifier hash computed?
2. **Witness Selection**: Does the Optimism Sepolia contract have the correct witnesses?
3. **Epoch Management**: How are witness epochs managed and rotated?
4. **Cross-Verification**: How does off-chain verification relate to on-chain verification?

## Code Example

```javascript
// Recreate signature verification
const { ethers } = require('ethers');

const message = `${proof.claimData.identifier}\n${proof.claimData.owner}\n${proof.claimData.timestampS}\n${proof.claimData.epoch}`;

const recoveredSigner = ethers.verifyMessage(message, proof.signatures[0]);
const expectedWitness = proof.witnesses[0].id;

console.log('Signature valid:', recoveredSigner.toLowerCase() === expectedWitness.toLowerCase());
```

This analysis shows how Reclaim Protocol provides cryptographic proof that witnesses attested to claims with specific data extraction rules, enabling privacy-preserving verification of web data.