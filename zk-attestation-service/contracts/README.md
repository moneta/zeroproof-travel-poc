# ZeroProof Contracts

This directory contains the Solidity contracts for ZeroProof, a wrapper around the pre-deployed SP1 universal verifier.

## Contracts

### ZeroProofVerifier.sol

A lightweight wrapper contract that:
- Calls the pre-deployed universal SP1 verifier (`ISP1Verifier`)
- Validates proofs generated by the zk-attestation-service (`attester`)
- Provides helper methods to decode and validate public values
- Emits events for proof verification tracking

**Key functions:**
- `verifyProof(bytes32, bytes, bytes)` — Verify a proof (view function, no state change)
- `verifyProofWithDecoding(bytes32, bytes, bytes)` — Verify and decode public values in one call
- `decodePublicValues(bytes)` — Helper to decode public values structure

## Deployment

### Prerequisites

1. **Foundry** installed: `curl -L https://foundry.paradigm.xyz | bash && foundryup`
2. **Environment variables** set:
   ```bash
   export UNIVERSAL_VERIFIER="0x..."  # Pre-deployed SP1 verifier on your network
   export PRIVATE_KEY="0x..."         # Your deployer account (keep secure!)
   export RPC_URL="https://..."       # Network RPC endpoint
   ```

### Deploy

From the `zk-attestation-service` directory:

```bash
# Dry-run first (simulate without sending tx)
forge script script/Deploy.s.sol:DeployZeroProofVerifier \
  --rpc-url $RPC_URL \
  --private-key $PRIVATE_KEY

# Actual deployment (sends tx)
forge script script/Deploy.s.sol:DeployZeroProofVerifier \
  --rpc-url $RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast
```

The script will print:
```
Wrapper address:       0x...
Universal verifier:    0x...
Deployer:              0x...
```

Record the **wrapper address** — Agent A calls this contract.

## Usage in Agent A

### Verification Flow

1. **Attester** generates a proof:
   - Returns: `vk_hash` (bytes32), `publicValues` (bytes), `proofBytes` (bytes)

2. **Agent A** calls the wrapper contract:
   ```solidity
   bool ok = wrapper.verifyProof(vkHash, publicValues, proofBytes);
   // or with decoding:
   (bool ok, uint256 a, uint256 b) = wrapper.verifyProofWithDecoding(vkHash, publicValues, proofBytes);
   ```

### Example (ethers.js)

```javascript
const { ethers } = require("ethers");

const verifierABI = [
  "function verifyProof(bytes32, bytes, bytes) view returns (bool)",
  "function verifyProofWithDecoding(bytes32, bytes, bytes) view returns (bool, uint256, uint256)"
];

const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
const contract = new ethers.Contract(process.env.ZERO_PROOF_VERIFIER_ADDR, verifierABI, provider);

// Verify proof
const vkHash = "0x...";  // From attester
const publicValues = "0x...";  // ABI-encoded from attester
const proofBytes = "0x...";  // From attester

const ok = await contract.verifyProof(vkHash, publicValues, proofBytes);
console.log("Proof valid:", ok);

// Verify and decode
const [isValid, valueA, valueB] = await contract.verifyProofWithDecoding(vkHash, publicValues, proofBytes);
console.log("Valid:", isValid, "Values:", valueA.toString(), valueB.toString());
```

### Example (cast)

```bash
cast call $ZERO_PROOF_VERIFIER_ADDR "verifyProof(bytes32,bytes,bytes)" \
  $VK_HASH $PUBLIC_VALUES_HEX $PROOF_HEX \
  --rpc-url $RPC_URL
```

Returns `true` (0x01) if proof is valid, reverts otherwise.

## Public Values Format

The `publicValues` bytes must match the encoding your SP1 program uses.

**Default assumption** (in decoding helpers): `abi.encode(uint256 a, uint256 b)`

**To customize:**
- Edit `decodePublicValues()` and `verifyProofWithDecoding()` in `ZeroProofVerifier.sol` to match your program's output struct.
- Example for struct `struct Output { uint256 price; uint256 timestamp; address user; }`:
  ```solidity
  (uint256 price, uint256 timestamp, address user) = abi.decode(publicValues, (uint256, uint256, address));
  ```

## Gas Costs

- **verifyProof()**: ~100k–300k gas (depends on Groth16 vs Plonk and proof size)
- Actual cost varies by:
  - Proof mode (Groth16 is cheaper)
  - Network (different base fee)
  - SP1 universal verifier implementation

## Events

```solidity
event ProofVerified(address indexed caller, bytes32 indexed vkHash, bytes32 publicHash);
```

Emitted every time a proof is successfully verified. Useful for off-chain indexing and audit trails.

## Security Considerations

- The wrapper assumes the **UNIVERSAL_VERIFIER address is correct** and points to the real SP1 verifier. Verify this before deployment.
- The wrapper is **stateless** — it only reads from the universal verifier, no storage attacks.
- **Public values decoding** is custom to your program; ensure the types match exactly.
- If the universal verifier changes, deploy a new wrapper pointing to the new address.

## Next Steps

1. Set `UNIVERSAL_VERIFIER` to the pre-deployed SP1 verifier address on your network.
2. Deploy using the script above.
3. Update Agent A to call `ZeroProofVerifier.verifyProof(...)` instead of the universal verifier directly.
4. (Optional) Add custom validation logic to the wrapper (e.g., check `publicValues` constraints).
